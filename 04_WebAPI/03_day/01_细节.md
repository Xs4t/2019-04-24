# 一些细节

## 关于 appendChild

我们上课只说了，假如想把 div 插入到 body 中，代码如下：

```javascript
var oDiv = document.querySelector('div');
document.body.appendChild(oDiv);
```

上面代码必然没有任何问题，但这里还有一点需要大家注意的是，appendChild 在插入的时候其实是做了两件事的：

1. 先把 oDiv 从原有的父级中删除
2. 再添加到新的父级中

如果还是不理解上面说的话，大家看下下面的例子就清楚了，目的是：点击按钮把上面 ul 中的第一个元素移动到下面的 ul 中

```html
<ul id="ul1">
    <li>aaa</li>
    <li>bbb</li>
    <li>ccc</li>
    <li>ddd</li>
</ul>
<button id="btn">插入下面</button>
<ul id="ul2"></ul>
<script>
var oUl1 = document.querySelector('#ul1');
var oBtn = document.querySelector('#btn');
var oUl2 = document.querySelector('#ul2');
oBtn.onclick = function() {
    var oLi = oUl1.children[0];
    // 每点击一次 oUl2 中确实添加了一个新的元素，但请注意！oUl1 中也确实少了这个元素，相当于做了一步这个操作：oUl1.removeChild(oLi);
    oUl2.appendChild(oLi);
};
</script>
```

**下面内容先不建议查看，后面我们学习了 sort 排序、伪数组转数组的方法后比较适合**

好，其实我们可以利用 appendChild 的这个特性来做一些有意思的操作，例如排序：

```html
<ul id="ul1">
    <li>5</li>
    <li>2</li>
    <li>3</li>
    <li>1</li>
    <li>4</li>
</ul>
<button id="btn">点击</button>
<script>
var oUl1 = document.querySelector('#ul1');
var aLi = oUl1.querySelectorAll('li');
var oBtn = document.querySelector('#btn');

// 先把伪数组 aLi 转成真正的数组，目的是为了使用数组的方法 sort() 来进行排序
// Array.prototype.slice.call(伪数组)、Array.from(伪数组)、[...伪数组]，这三种方式也都可以把伪数组转成数组，下面我们使用的是大家能看的懂的方式
var arr = [];
for(var i = 0; i < aLi.length; i ++) {
    arr.push(aLi[i]);
}

arr.sort(function(li1, li2) {
    return parseInt(li1.innerHTML) - parseInt(li2.innerHTML);
});

// 此时 arr 中已经排好序的一堆 li 元素了
oBtn.onclick = function() {
    // 分别把排好序的数组中的每个元素插入到 oUl1 中（注意每次插入的同时也会把oUl1中相同的元素先给干掉，所以也就不存在重复的问题）
    for(var i = 0; i < arr.length; i ++) {
        oUl1.appendChild(arr[i]);
    }
};
```

## 关于事件委托

课上我们说了事件委托的好处是提高性能，其实它还有另外一个好处也非常重要，需要大家清楚：就是通过事件委托的形式进行绑定的事件，这个事件效果对内部新增的元素也依然有效，什么意思呢？

先来看个给每个元素分别绑定事件（不通过事件委托）的例子存在的“小问题”，代码如下：

```html
<button id="btn1">添加元素</button>
<ul id="ul1">
    <li>0001</li>
    <li>0002</li>
    <li>0003</li>
</ul>
<script>
var oBtn = document.querySelector('#btn1');
var oUl = document.querySelector('#ul1');
var aLi = oUl.querySelectorAll('li');

// 假如我想给上面 3 个 li 绑定事件，可以通过下面的形式：

for(var i = 0; i < aLi.length; i ++) {
    aLi[i].onclick = function() {
        console.log(this.innerHTML);
    };
}

// 上面代码必然没有什么问题，每点击一个 li 都会 log 对应的内容

// 注意：假如这时候我点击按钮并往 ul 中新增元素，那么点击新增的元素还会有事件效果吗？
// 答案肯定是不会的，其实这也比较容易理解，因为一打开页面上面选择元素的代码 var aLi = oUl.querySelectorAll('li'); 已经执行完毕，我们只是给最开始选择到的 3 个 li 绑定了事件而已，再添加新的元素的话，并没有进行对应的事件绑定操作
oBtn.onclick = function() {
    var oLi = document.createElement('li');
    oLi.innerHTML = Math.floor(Math.random() * 100);
    oUl.appendChild(oLi);
};
</script>
```

使用事件委托解决上面的问题，代码如下：

```html
<button id="btn1">添加元素</button>
<ul id="ul1">
    <li>0001</li>
    <li>0002</li>
    <li>0003</li>
</ul>
<script>
var oBtn = document.querySelector('#btn1');
var oUl = document.querySelector('#ul1');
var aLi = oUl.querySelectorAll('li');

// 事件委托的形式给每个 li 绑定事件
oUl.onclick = function (e) {
    console.log(e.target.innerHTML);
};

// 这样就不会有问题了，即便是点击新增的 li 元素，也会有事件效果，因为我们的事件是绑定在它的父级上的（会冒泡）
oBtn.onclick = function () {
    var oLi = document.createElement('li');
    oLi.innerHTML = Math.floor(Math.random() * 100);
    oUl.appendChild(oLi);
};
```

